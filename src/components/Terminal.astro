---
interface Props {
  command?: string
  lines: Array<{
    text: string
    type?: 'command' | 'output' | 'success' | 'warning' | 'critical' | 'info' | 'muted'
    delay?: number
  }>
  autoplay?: boolean
  class?: string
}

const { command, lines, autoplay = true, class: className = '' } = Astro.props

const terminalId = `terminal-${Math.random().toString(36).substr(2, 9)}`
---

<div class={`terminal-container relative ${className}`}>
  <!-- Glow effect behind terminal -->
  <div class="absolute -inset-1 bg-gradient-to-b from-lavender/20 via-buoy/10 to-transparent rounded-xl blur-xl opacity-50"></div>

  <!-- Terminal window -->
  <div class="relative bg-navy-dark border border-navy-light/30 rounded-xl overflow-hidden shadow-2xl">
    <!-- Title bar -->
    <div class="flex items-center gap-2 px-4 py-3 bg-navy border-b border-navy-light/20">
      <div class="flex items-center gap-1.5">
        <div class="w-3 h-3 rounded-full bg-critical/80"></div>
        <div class="w-3 h-3 rounded-full bg-warning/80"></div>
        <div class="w-3 h-3 rounded-full bg-success/80"></div>
      </div>
      <div class="flex-1 text-center">
        <span class="text-xs text-slate font-mono">buoy-cli</span>
      </div>
      <div class="w-12"></div>
    </div>

    <!-- Terminal content -->
    <div class="p-4 sm:p-6 font-mono text-sm leading-relaxed min-h-[300px]" id={terminalId}>
      {command && (
        <div class="flex items-center gap-2 mb-4">
          <span class="text-buoy">$</span>
          <span class="terminal-command text-light" data-text={command}></span>
          <span class="cursor-blink opacity-0" id={`${terminalId}-cursor`}></span>
        </div>
      )}

      <div class="terminal-output space-y-1">
        {lines.map((line, index) => {
          const colorClass = {
            command: 'text-light',
            output: 'text-slate',
            success: 'text-success',
            warning: 'text-warning',
            critical: 'text-critical',
            info: 'text-info',
            muted: 'text-slate-dark',
          }[line.type || 'output']

          return (
            <div
              class={`terminal-line ${colorClass} opacity-0`}
              data-delay={line.delay || (index * 100)}
              set:html={line.text}
            />
          )
        })}
      </div>
    </div>

    <!-- Scan line effect -->
    <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-xl">
      <div class="scan-line absolute w-full h-px bg-gradient-to-r from-transparent via-buoy/30 to-transparent"></div>
    </div>
  </div>
</div>

<style>
  @keyframes scanline {
    0% { transform: translateY(-100%); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translateY(400px); opacity: 0; }
  }

  .scan-line {
    animation: scanline 4s ease-in-out infinite;
    animation-delay: 2s;
  }

  @keyframes typewriter {
    from { width: 0; }
    to { width: 100%; }
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .terminal-line.visible {
    animation: fadeIn 0.3s ease-out forwards;
  }
</style>

<script define:vars={{ terminalId, command, autoplay }}>
  function initTerminal() {
    const terminal = document.getElementById(terminalId)
    if (!terminal) return

    const commandEl = terminal.querySelector('.terminal-command')
    const cursorEl = document.getElementById(`${terminalId}-cursor`)
    const lines = terminal.querySelectorAll('.terminal-line')

    let currentChar = 0
    let currentLine = 0

    // Typewriter effect for command
    function typeCommand() {
      if (!commandEl || !command) {
        showLines()
        return
      }

      cursorEl?.classList.remove('opacity-0')

      const typeInterval = setInterval(() => {
        if (currentChar < command.length) {
          commandEl.textContent = command.substring(0, currentChar + 1)
          currentChar++
        } else {
          clearInterval(typeInterval)
          cursorEl?.classList.add('opacity-0')
          setTimeout(showLines, 500)
        }
      }, 50)
    }

    // Show output lines with staggered animation
    function showLines() {
      lines.forEach((line, index) => {
        const delay = parseInt(line.getAttribute('data-delay') || '0')
        setTimeout(() => {
          line.classList.add('visible')
        }, delay)
      })
    }

    // Intersection Observer for autoplay
    if (autoplay) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            typeCommand()
            observer.disconnect()
          }
        })
      }, { threshold: 0.1 })

      observer.observe(terminal)
    } else {
      typeCommand()
    }
  }

  // Run on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTerminal)
  } else {
    initTerminal()
  }
</script>
